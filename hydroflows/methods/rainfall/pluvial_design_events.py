"""Pluvial design events method."""

import os
from pathlib import Path
from typing import Literal

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import xarray as xr
from pydantic import BaseModel, FilePath

from hydroflows._typing import ListOfFloat, ListOfInt
from hydroflows.methods.method import Method
from hydroflows.methods.rainfall.functions import eva_idf, get_hyetograph
from hydroflows.workflows.events import EventCatalog

__all__ = ["PluvialDesignEvents"]


class Input(BaseModel):
    """Input parameters.

    This class represents the input data
    required for the :py:class:`PluvialDesignEvents` method.
    """

    time_series_nc: FilePath
    """
    The file path to the rainfall time series in NetCDF format which are used
    to apply EVA and derive design events. This file should contain a time dimension
    This time series can be derived either by the
    :py:class:`hydroflows.methods.rainfall.get_ERA5_rainfall.GetERA5Rainfall`
    or can be directly supplied by the user.
    """


class Output(BaseModel):
    """Output parameters.

    This class represents the output data
    generated by the :py:class:`PluvialDesignEvents` method.
    """

    event_catalog: Path
    """The path to the event catalog yml file that contains the derived
    pluvial event configurations. This event catalog can be created from
    a dictionary using the :py:class:`hydroflows.workflows.events.EventCatalog` class.
    """


class Params(BaseModel):
    """Parameters.

    Instances of this class are used in the :py:class:`PluvialDesignEvents`
    method to define the required settings.

    This class utilizes the :py:class:`Params <hydroflows.methods.rainfall.get_ERA5_rainfall.Params>`,
    :py:class:`Input <hydroflows.methods.rainfall.get_ERA5_rainfall.Input>`, and
    :py:class:`Output <hydroflows.methods.rainfall.get_ERA5_rainfall.Output>` classes .

    See Also
    --------
    :py:function:`hydroflows.methods.rainfall.functions.eva_idf`
    :py:function:`hydroflows.methods.rainfall.functions.get_hyetograph`
        For more details on the function used to select events apply EVA
        and derive design hyetographs.
    """

    # durations for IDF
    durations: ListOfInt = [1, 2, 3, 6, 12, 24, 36, 48]
    """Intensity Duration Frequencies provided as multiply of the data time step."""

    min_dist_days: int = 0
    """Minimum distance between events/peaks measured in days."""

    ev_type: Literal["BM", "POT"] = "BM"
    """Method to select events/peaks. Valid options are 'BM' for block maxima or 'POT' for Peak over threshold."""

    qthresh: float = 0.95
    """Quantile threshold used with peaks over threshold method."""

    min_sample_perc: int = 80
    """Minimum sample percentage in a valid block. Peaks of invalid bins are set to NaN."""

    time_dim: str = "time"
    """Time dimension of the input time series provided in :py:class:`Input` class."""

    rps: ListOfFloat = [1, 2, 5, 10, 20, 50, 100]
    """Return periods of interest."""

    plot_fig: bool = True
    """Determines whether to plot figures, including the derived design hyetographs
    as well as the calculated IDF curves per return period."""


class PluvialDesignEvents(Method):
    """Rule for generating pluvial design events.

    This class utilizes the :py:class:`Params <hydroflows.methods.rainfall.pluvial_design_events.Params>`,
    :py:class:`Input <hydroflows.methods.rainfall.pluvial_design_events.Input>`, and
    :py:class:`Output <hydroflows.methods.rainfall.pluvial_design_events.Output>` classes to derive
    design pluvial events from a timeseries.
    """

    name: str = "pluvial_design_events"
    params: Params = Params()  # optional parameters
    input: Input
    output: Output

    def run(self):
        """Run the Pluvial design events method."""
        da = xr.open_dataarray(self.input.time_series_nc)
        time_dim = self.params.time_dim
        if da.ndim > 1 or time_dim not in da.dims:
            raise ValueError()

        dt = pd.Timedelta(da[time_dim].values[1] - da[time_dim].values[0])
        int(pd.Timedelta(self.params.min_dist_days, "d") / dt)

        # sample size per year
        min_sample_size = (
            pd.Timedelta(1, "A") / dt * (self.params.min_sample_perc / 100)
        )

        # specify the max event duration
        event_duration = self.params.durations[-1]

        # fit distribution per duration
        ds_idf = eva_idf(
            da,
            ev_type=self.params.ev_type,
            durations=self.params.durations,
            rps=np.maximum(1.001, self.params.rps),
            qthresh=self.params.qthresh,
            min_sample_size=min_sample_size,
        )

        ds_idf = ds_idf.assign_coords(rps=self.params.rps)
        # make sure there are no negative values
        ds_idf["return_values"] = xr.where(
            ds_idf["return_values"] < 0, 0, ds_idf["return_values"]
        )

        # Get design events hyetograph for each return period
        p_hyetograph = get_hyetograph(
            ds_idf["return_values"], dt=1, length=event_duration
        )

        # make sure there are no negative values
        p_hyetograph = xr.where(p_hyetograph < 0, 0, p_hyetograph)

        root = self.output.event_catalog.parent
        os.makedirs(root, exist_ok=True)

        # save plots
        if self.params.plot_fig:
            # create a folder to save the figs
            fn_plots = os.path.join(root, "figs")

            os.makedirs(fn_plots, exist_ok=True)

            # Plot IDF curves
            fig, ax = plt.subplots(1, 1, figsize=(8, 4), sharex=True)
            df = (
                ds_idf["return_values"]
                .rename({"rps": "Return period\n[year]"})
                .to_pandas()
            )
            df.plot(ax=ax)
            ax.set_ylabel("rainfall intensity [mm/hour]")
            ax.set_xlabel("event duration [hour]")
            ax.set_title("Rainfall IDF curves")
            ax.grid(True)
            fig.tight_layout()
            fig.savefig(
                os.path.join(fn_plots, "rainfall_idf.png"), dpi=150, bbox_inches="tight"
            )

            # Plot hyetographs
            fig, ax = plt.subplots(1, 1, figsize=(8, 4), sharex=True)
            p_hyetograph.rename({"rps": "Return period\n[year]"}).plot.step(
                x="time",
                where="mid",
                ax=ax,
            )
            ax.set_ylabel("rainfall intensity [mm/hour]")
            ax.set_xlabel("time [hour]")
            ax.set_title("Rainfall hyetographs")
            ax.grid(True)
            fig.tight_layout()
            fig.savefig(
                os.path.join(fn_plots, "rainfall_hyetographs.png"),
                dpi=150,
                bbox_inches="tight",
            )

        # random starting time
        dt0 = pd.to_datetime("2020-01-01")
        time_delta = pd.to_timedelta(p_hyetograph["time"], unit="h").round("10min")
        p_hyetograph["time"] = dt0 + time_delta
        p_hyetograph = p_hyetograph.reset_coords(drop=True)

        events_list = []
        for i, rp in enumerate(p_hyetograph.rps.values):
            # save p_rp as csv files
            name = f"p_event{int(i+1):02d}"
            events_fn = Path(root, f"{name}.csv")
            p_hyetograph.sel(rps=rp).to_pandas().round(2).to_csv(events_fn)

            event = {
                "name": name,
                "forcings": [{"type": "rainfall", "path": f"{name}.csv"}],
                "probability": 1 / rp,
            }
            events_list.append(event)

        # make a data catalog
        event_catalog = EventCatalog(
            root=root,
            events=events_list,
        )

        event_catalog.to_yaml(self.output.event_catalog)
