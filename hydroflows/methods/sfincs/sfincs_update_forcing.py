"""SFINCS Update forcing method."""

# from datetime.datetime import strftime
from pathlib import Path
from typing import Optional

import numpy as np
from hydromt_sfincs import SfincsModel
from pydantic import BaseModel, FilePath

from ...utils import make_relative_paths
from ...workflows.events import EventCatalog
from ..method import Method

__all__ = ["SfincsUpdateForcing"]


def parse_event_sfincs(root, event, out_root):
    # Init sfincs and update root, config
    sf = SfincsModel(root=root, mode="r", write_gis=False)

    # update model simulation time range
    fmt = "%Y%m%d %H%M%S"  # sfincs inp time format
    dt_sec = (event.time_range[1] - event.time_range[0]).total_seconds()
    sf.config.update(
        {
            "tref": event.time_range[0].strftime(fmt),
            "tstart": event.time_range[0].strftime(fmt),
            "tstop": event.time_range[1].strftime(fmt),
            "dtout": dt_sec,  # save only single output
            "dtmaxout": dt_sec,
        }
    )

    # Set forcings, update config with relative paths
    config = make_relative_paths(sf.config, root, out_root)
    for forcing in event.forcings:
        match forcing.type:
            case "water_level":
                sf.setup_waterlevel_forcing(
                    timeseries=forcing.data,
                    merge=False,
                )
                config.update({"bzsfile": "sfincs.bzs"})

            case "discharge":
                all_locs = sf.forcing["dis"].vector.to_gdf()
                # find overlapping indexes
                locs = all_locs.loc[np.int64(forcing.data.columns)]
                sf.setup_discharge_forcing(
                    timeseries=forcing.data, merge=False, locations=locs
                )
                config.update({"disfile": "sfincs.dis"})
                config.update({"srcfile": "sfincs.src"})

            case "rainfall":
                # if rainfall occurs, a stability issue in SFINCS makes sfincs crash when the courant condition is
                # set to (default) 0.5. Therefore set to 0.1
                sf.setup_config(alpha=0.1)
                sf.setup_precip_forcing(
                    timeseries=forcing.data,
                )
                config.update({"precipfile": "sfincs.precip"})

    # change root and update config
    sf.set_root(out_root, mode="w+")
    sf.setup_config(**config)
    # Write forcing and config only
    sf.write_forcing()
    sf.write_config()


class Input(BaseModel):
    """Input parameters.

    This class represents the input data
    required for the :py:class:`SfincsUpdateForcing` method.
    """

    sfincs_inp: FilePath
    """The file path to the Sfincs (inp) configuration file to update."""

    event_catalog: FilePath
    """The path to the event catalog yml file that contains the derived
    design event configurations.

    This event catalog can be produced either by
    :py:class:`hydroflows.methods.wflow.wflow_design_hydro.WflowDesignHydro` for fluvial events
    or by :py:class:`hydroflows.methods.rainfall.pluvial_design_events.PluvialDesignEvents` for pluvial events.
    Additionally the design event drivers can be combined into a signle catalog using the
    :py:class:`hydroflows.workflows.events.EventCatalog` class.
    """


class Output(BaseModel):
    """Output parameters.

    This class represents the output data
    generated by the :py:class:`SfincsUpdateForcing` method.
    """

    sfincs_inp: Path
    """The path to the updated Sfincs configuration (inp) file per design event."""


class Params(BaseModel):
    """Parameters.

    Instances of this class are used in the :py:class:`SfincsUpdateForcing`
    method to define the required settings.
    """

    event_name: str
    """Event name."""

    dtout: Optional[int] = None
    """Placeholder for docstrings."""


class SfincsUpdateForcing(Method):
    """Rule for updating Sfincs forcing with data from an event catalog.

    This class utilizes the :py:class:`Params <hydroflows.methods.sfincs.sfincs_update_forcing.Params>`,
    :py:class:`Input <hydroflows.methods.sfincs.sfincs_update_forcing.Input>`, and
    :py:class:`Output <hydroflows.methods.sfincs.sfincs_update_forcing.Output>` classes to run
    the postprocessing from the Sfincs netcdf to generate an inundation map.
    """

    name: str = "sfincs_update_forcing"
    params: Params
    input: Input
    output: Output

    def run(self):
        """Run the SfincsUpdateForcing method."""
        # Unpack Input, Output, Params
        root = self.input.sfincs_inp.parent
        event_file = self.input.event_catalog
        out_root = self.output.sfincs_inp.parent
        event_name = self.params.event_name

        # Fetch events from event catalog and parse forcing
        event_catalog = EventCatalog.from_yaml(event_file)
        event = event_catalog.get_event_data(event_name)
        parse_event_sfincs(root, event, out_root)
