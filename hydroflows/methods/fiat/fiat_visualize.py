"""Module/ Rule for building FIAT models."""

import os
from pathlib import Path
from typing import Union

import geopandas as gpd
import pandas as pd
import toml
from fiat_toolbox.infographics.infographics_factory import InforgraphicFactory
from fiat_toolbox.metrics_writer.fiat_write_metrics_file import MetricsFileWriter
from hydromt.config import configread
from hydromt.raster import full_from_transform
from pydantic import FilePath
from shapely.geometry import box

from hydroflows.cfg import CFG_DIR
from hydroflows.workflow.method import Method
from hydroflows.workflow.method_parameters import Parameters

__all__ = ["FIATVisualize"]


class Input(Parameters):
    """Input parameters.

    This class represents the input data
    required for the :py:class:`FIATVisualize` method.
    """

    fiat_cfg: Path
    """
    The file path to the output of the FIAT model.
    """

    event_name: Path
    """Path to the eventset cfg file."""


class Output(Parameters):
    """Output parameters.

    This class represents the output data
    generated by the :py:class:`FIATVisualize` method.
    """

    fiat_infometrics: Path
    """The file path to the FIAT infometrics output."""

    fiat_infographics: Path
    """The file path to the FIAT infographics output."""


class Params(Parameters):
    """Parameters for the :py:class:`FIATVisualize`.

    Instances of this class are used in the :py:class:`FIATVisualize`
    method to define the required settings.

    See Also
    --------
    :py:class:`hydromt_fiat.fiat.FiatModel`
        For more details on the FiatModel used in hydromt_fiat.
    """

    output_dir: Path = ("models/fiat/fiat_metrics",)
    """The file path to the FIAT infometrics output."""

    aggregation: bool = False
    """Boolean to default aggregate or by aggregation area."""


class FIATVisualize(Method):
    """Rule for visualizing FIAT output."""

    name: str = "fiat_visualize"

    def __init__(
        self,
        fiat_cfg: Path,
        event_name: Path,
        output_dir: Path = "models/fiat/fiat_metrics",
        aggregation: bool = False,
        infographics_template: FilePath = CFG_DIR
        / "infographics"
        / "config_charts.toml",
        infometrics_template: FilePath = CFG_DIR
        / "infometrics"
        / "metrics_config.toml",
    ) -> None:
        """Create and validate a FIATVisualize instance.

        Parameters
        ----------
        fiat_cfg: Path
            The file path to the output of the FIAT model.
        event_name: Path
            The file path to the event set output of the hydromt SFINCS model.
        output_dir: Path = "models/fiat/fiat_metrics"
            The file path to the output of the FIAT infometrics and infographics.
        aggregation: bool = None
            Boolean to default aggregate or by aggregation area.
        infographics_template: FilePath = CFG_DIR / "config_charts.toml"
            Path to the infographics template file.
        infometrics_template: FilePath = CFG_DIR / "metrics_config.toml"
            Path to the infometrics template file.

        See Also
        --------
        :py:class:`fiat_visualize Input <~hydroflows.methods.fiat.fiat_visualize.Input>`,
        :py:class:`fiat_visualize Output <~hydroflows.methods.fiat.fiat_visualize.Output>`,
        :py:class:`fiat_visualize Params <~hydroflows.methods.fiat.fiat_visualize.Params>`,
        :py:class:`hydromt_fiat.fiat.FIATModel`
        """
        self.params: Params = Params(output_dir=output_dir, aggregation=aggregation)
        self.input: Input = Input(
            fiat_cfg=fiat_cfg,
            event_name=event_name,
        )
        self.output: Output = Output(
            fiat_infometrics=self.params.output_dir
            / f"Infometrics_{self.input.event_name.stem}.csv",
            fiat_infographics=self.params.output_dir
            / f"{self.input.event_name.stem}_metrics.html",
        )

        self.infographics_template = infographics_template
        self.infometrics_template = infometrics_template

    def run(self):
        """Run the FIATVisualize method."""
        events = configread(self.input.event_name)["events"]
        if len(events) > 1:
            mode = "risk"
        else:
            mode = "single_event"

        scenario_name = self.input.event_name.stem

        # Write the metrics to file
        if mode == "risk":
            metrics_config = (
                self.infometrics_template.parent / "metrics_config_risk.toml"
            )
        else:
            metrics_config = self.infometrics_template

        metrics_writer = MetricsFileWriter(metrics_config)
        infometrics_name = f"Infometrics_{(scenario_name)}.csv"
        metrics_full_path = metrics_writer.parse_metrics_to_file(
            df_results=pd.read_csv(
                self.input.fiat_cfg.parent / "output" / "output.csv"
            ),
            metrics_path=self.output.fiat_infometrics.parent.joinpath(infometrics_name),
            write_aggregate=None,
        )
        # Write aggregated metrics config files
        if self.params.aggregation:
            for file in self.infometrics_template.parent.iterdir():
                with open(file, "r") as f:
                    infometrics_cfg = toml.load(f)
                aggregation_areas = get_aggregation_areas(self.input.fiat_cfg.parent)
                aggr_names = []
                for aggregation_area in aggregation_areas:
                    name = aggregation_area["name"]
                    aggr_names.append(name)
                infometrics_cfg["aggregateBy"] = aggr_names
                with open(file, "w") as f:
                    toml.dump(infometrics_cfg, f)
        else:
            for file in self.infometrics_template.parent.iterdir():
                with open(file, "r") as f:
                    infometrics_cfg = toml.load(f)
                infometrics_cfg["aggregateBy"] = "vector_grid"
                with open(file, "w") as f:
                    toml.dump(infometrics_cfg, f)
            aggregation_areas = create_vector_grid(self.input.fiat_cfg.parent)

        # Write metrics
        metrics_writer.parse_metrics_to_file(
            df_results=pd.read_csv(
                self.input.fiat_cfg.parent / "output" / "output.csv"
            ),
            metrics_path=self.output.fiat_infometrics.parent.joinpath(infometrics_name),
            write_aggregate="all",
        )
        create_output_map(
            aggregation_areas,
            self.output.fiat_infometrics.parent.joinpath(infometrics_name),
            self.input.fiat_cfg.parent,
            self.input.event_name.stem,
            self.params.output_dir,
        )

        # Write the infographic
        InforgraphicFactory.create_infographic_file_writer(
            infographic_mode=mode,
            scenario_name=scenario_name,
            metrics_full_path=metrics_full_path,
            config_base_path=Path(self.infographics_template.parent),
            output_base_path=self.output.fiat_infographics.parent,
        ).write_infographics_to_file()


def create_output_map(
    aggregation_areas: list,
    aggregation_metrics_fn: Path,
    fiat_model: Path,
    event_name: str,
    fn_aggregated_metrics: Path = None,
):
    if not fn_aggregated_metrics:
        print("not implemented")
        # Create vector map and aggregate by user resolution.
    else:
        for aggregation_area in aggregation_areas:
            name = aggregation_area["name"]
            fn = aggregation_area["file"]
            field_name = aggregation_area["field_name"]
            gdf_aggregation = gpd.read_file(Path(fiat_model / fn))
            metrics = pd.read_csv(
                Path(
                    fn_aggregated_metrics
                    / [f for f in os.listdir(fn_aggregated_metrics) if name in f][0]
                )
            ).iloc[3:, 0:]
            metrics = metrics.sort_values(metrics.columns[0])
            metrics.reset_index(inplace=True, drop=True)
            gdf_new_aggr = gdf_aggregation.copy().sort_values(field_name)
            gdf_new_aggr.reset_index(inplace=True, drop=True)
            gdf_new_aggr["aggregation"] = metrics.iloc[0:, 0]
            assert gdf_new_aggr[field_name].equals(gdf_new_aggr["aggregation"])

            for column in metrics.columns:
                if "TotalDamage" in column or "ExpectedAnnualDamages" in column:
                    metrics_float = pd.to_numeric(metrics[column], errors="coerce")
                    gdf_new_aggr[column] = metrics_float

            del gdf_new_aggr["aggregation"]
            gdf_new_aggr.to_file(
                Path(
                    fn_aggregated_metrics / f"{name}_total_damages_{event_name}.geojson"
                )
            )


def get_aggregation_areas(fiat_model):
    spatial_joins = toml.load(Path(fiat_model / "spatial_joins.toml"))
    aggregation_areas = spatial_joins["aggregation_areas"]
    return aggregation_areas


def create_vector_grid(
    fiat_model: Path, res_x: Union[int, float] = 0.01, res_y: Union[int, float] = 0.01
):
    rotation = 0
    region = gpd.read_file(Path(fiat_model / "geoms" / "region.geojson"))
    bounds = region.bounds
    width = int((bounds["maxx"] - bounds["minx"]) / res_x)
    height = int((bounds["maxy"] - bounds["miny"]) / res_y)

    # chatgbt
    length_x = bounds["maxx"] - bounds["minx"]
    length_y = bounds["maxy"] - bounds["miny"]

    # Adjust resolution or length to ensure alignment
    res_x = length_x / int(length_x / res_x)
    res_y = length_y / int(length_y / res_y)

    transform_affine = (
        res_x[0],
        rotation,
        bounds["minx"][0],
        rotation,
        -res_y[0],
        bounds["maxy"][0],
    )
    shape = (width, height)

    # aggregation_areas is the vector file of the grid.
    aggregation_areas = full_from_transform(transform_affine, shape)

    # Create vector file
    geometries = []
    for j, y in enumerate(aggregation_areas["y"]):
        for i, x in enumerate(aggregation_areas["x"]):
            cell_geom = box(
                x.values - res_x / 2,
                y.values - res_y / 2,
                x.values + res_x / 2,
                y.values + res_y / 2,
            )
            geometries.append(
                {"geometry": cell_geom, "value": aggregation_areas[j, i].item()}
            )

    # Create a GeoDataFrame from the geometries
    crs = region.crs
    gdf = gpd.GeoDataFrame(geometries, crs=crs)
    # cells need values 1-range
    gdf["value"] = range(1, len(gdf["geometry"]) + 1, 1)
    gdf["value"] = gdf["value"].astype(str)
    gdf.rename(columns={"value": "default_aggregation"}, inplace=True)

    # Save to a vector file (e.g., GeoJSON or Shapefile)
    aggregation_areas_fn = r"C:\Users\rautenba\OneDrive - Stichting Deltares\Documents\test\grid_vector.geojson"
    gdf.to_file(aggregation_areas_fn)
    return aggregation_areas_fn
